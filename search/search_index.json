{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Description \u00b6 This library contains useful data structures and algorithms that are commonly used in coding interviews. The goal of this project is to provide modules that can actually be used to solve interviewing problems. This project is NOT a code dump of solutions to interviewing problems. The classes and functions were designed to be compatible with LeetCode. Installation \u00b6 The pyinterview package can be installed directly using pip . pip install pyinterview Usage \u00b6 Users can import common data structures and algorithms from several different modules. For example: To manually construct a binary tree, import the TreeNode class from the trees module: from pyinterview.trees import TreeNode root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) To construct a undirected graph adjacency list, import the undirected_adj_list function from the graphs module: from pyinterview.graphs import undirected_adj_list edges = [('A', 'B'), ('A', 'C'), ('C', 'D')] adj_list = undirected_adj_list(edges) Documentation \u00b6 The documentation is a work in progress, but contributions are welcome! Linked lists \u00b6 The ListNode class consists of a val attribute and a next attribute. It can be used to create individual nodes in a linked list. Given the head node of a linked list, many functions in linked_lists.py , including reverse_LL and pop_LL , can be used to operate on the linked list. pyinterview documentation","title":"Home"},{"location":"#description","text":"This library contains useful data structures and algorithms that are commonly used in coding interviews. The goal of this project is to provide modules that can actually be used to solve interviewing problems. This project is NOT a code dump of solutions to interviewing problems. The classes and functions were designed to be compatible with LeetCode.","title":"Description"},{"location":"#installation","text":"The pyinterview package can be installed directly using pip . pip install pyinterview","title":"Installation"},{"location":"#usage","text":"Users can import common data structures and algorithms from several different modules. For example: To manually construct a binary tree, import the TreeNode class from the trees module: from pyinterview.trees import TreeNode root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) To construct a undirected graph adjacency list, import the undirected_adj_list function from the graphs module: from pyinterview.graphs import undirected_adj_list edges = [('A', 'B'), ('A', 'C'), ('C', 'D')] adj_list = undirected_adj_list(edges)","title":"Usage"},{"location":"#documentation","text":"The documentation is a work in progress, but contributions are welcome!","title":"Documentation"},{"location":"#linked-lists","text":"The ListNode class consists of a val attribute and a next attribute. It can be used to create individual nodes in a linked list. Given the head node of a linked list, many functions in linked_lists.py , including reverse_LL and pop_LL , can be used to operate on the linked list. pyinterview documentation","title":"Linked lists"},{"location":"algorithms/searching/","text":"Searching \u00b6 binary_search ( array , target ) \u00b6 Perform a binary search. Parameters: Name Type Description Default array list[int] The array in which to search. required target int The number to search for. required Returns: Type Description int The index of the target in the array. If target not found, return -1. Source code in pyinterview/searching.py def binary_search ( array : list [ int ], target : int ) -> int : \"\"\"Perform a binary search. Args: array (list[int]): The array in which to search. target (int): The number to search for. Returns: int: The index of the target in the array. If target not found, return -1. \"\"\" left = 0 right = len ( array ) - 1 while left <= right : mid = ( left + right ) // 2 if array [ mid ] == target : return mid elif array [ mid ] < target : left = mid + 1 elif array [ mid ] > target : right = mid - 1 return - 1","title":"Searching"},{"location":"algorithms/searching/#searching","text":"","title":"Searching"},{"location":"algorithms/searching/#pyinterview.searching.binary_search","text":"Perform a binary search. Parameters: Name Type Description Default array list[int] The array in which to search. required target int The number to search for. required Returns: Type Description int The index of the target in the array. If target not found, return -1. Source code in pyinterview/searching.py def binary_search ( array : list [ int ], target : int ) -> int : \"\"\"Perform a binary search. Args: array (list[int]): The array in which to search. target (int): The number to search for. Returns: int: The index of the target in the array. If target not found, return -1. \"\"\" left = 0 right = len ( array ) - 1 while left <= right : mid = ( left + right ) // 2 if array [ mid ] == target : return mid elif array [ mid ] < target : left = mid + 1 elif array [ mid ] > target : right = mid - 1 return - 1","title":"binary_search()"},{"location":"algorithms/sorting/","text":"Sorting \u00b6 bubble_sort ( nums ) \u00b6 Sort an array using the bubble sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def bubble_sort ( nums : list ) -> list : \"\"\"Sort an array using the bubble sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" n = len ( nums ) # iterate thorugh all elements in the array for i in range ( n - 1 ): for j in range ( 0 , n - i - 1 ): if nums [ j ] > nums [ j + 1 ]: nums [ j ], nums [ j + 1 ] = nums [ j + 1 ], nums [ j ] return nums merge_sort ( nums ) \u00b6 Sort an array using the merge sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def merge_sort ( nums : list ) -> list : \"\"\"Sort an array using the merge sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" def split_array ( nums : list ) -> list : \"\"\"Recursively split array in half. Args: nums (list): The unsorted input array. Returns: list: Returns a sorted array. \"\"\" if len ( nums ) <= 1 : return nums mid = len ( nums ) // 2 left = split_array ( nums [: mid ]) right = split_array ( nums [ mid :]) return merge_two ( left , right ) def merge_two ( a : list , b : list ) -> list : \"\"\"Merges two sorted arrays. Args: a (list): The first sorted array. b (list): The second sorted array. Returns: list: Returns sorted array containing all elements from a and b. \"\"\" result = [] i = j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] <= b [ j ]: result . append ( a [ i ]) i += 1 else : result . append ( b [ j ]) j += 1 while i < len ( a ): result . append ( a [ i ]) i += 1 while j < len ( b ): result . append ( b [ j ]) j += 1 return result return split_array ( nums ) quick_sort ( nums ) \u00b6 Sort an array using the quick sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def quick_sort ( nums : list ) -> list : \"\"\"Sort an array using the quick sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" if len ( nums ) == 0 : return [] pivot = nums [ randint ( 0 , len ( nums ) - 1 )] smaller = [ x for x in nums if x < pivot ] equal = [ x for x in nums if x == pivot ] greater = [ x for x in nums if x > pivot ] return quick_sort ( smaller ) + equal + quick_sort ( greater ) topological_sort ( edges ) \u00b6 Produce a topological sorting (if one exists) using a BFS approach. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description list An array with a non-unique topological order of nodes. Source code in pyinterview/sorting.py def topological_sort ( edges : Sequence [ Sequence ]) -> list : \"\"\"Produce a topological sorting (if one exists) using a BFS approach. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: list: An array with a non-unique topological order of nodes. \"\"\" adj_list = directed_adj_list ( edges ) indegrees = inbound_degrees ( adj_list ) sources = find_sources ( indegrees ) result = [] while len ( sources ) > 0 : source = sources . popleft () result . append ( source ) for neighbor in adj_list [ source ]: indegrees [ neighbor ] -= 1 if indegrees [ neighbor ] == 0 : sources . append ( neighbor ) return result [:: - 1 ] if len ( result ) == len ( adj_list ) else []","title":"Sorting"},{"location":"algorithms/sorting/#sorting","text":"","title":"Sorting"},{"location":"algorithms/sorting/#pyinterview.sorting.bubble_sort","text":"Sort an array using the bubble sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def bubble_sort ( nums : list ) -> list : \"\"\"Sort an array using the bubble sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" n = len ( nums ) # iterate thorugh all elements in the array for i in range ( n - 1 ): for j in range ( 0 , n - i - 1 ): if nums [ j ] > nums [ j + 1 ]: nums [ j ], nums [ j + 1 ] = nums [ j + 1 ], nums [ j ] return nums","title":"bubble_sort()"},{"location":"algorithms/sorting/#pyinterview.sorting.merge_sort","text":"Sort an array using the merge sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def merge_sort ( nums : list ) -> list : \"\"\"Sort an array using the merge sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" def split_array ( nums : list ) -> list : \"\"\"Recursively split array in half. Args: nums (list): The unsorted input array. Returns: list: Returns a sorted array. \"\"\" if len ( nums ) <= 1 : return nums mid = len ( nums ) // 2 left = split_array ( nums [: mid ]) right = split_array ( nums [ mid :]) return merge_two ( left , right ) def merge_two ( a : list , b : list ) -> list : \"\"\"Merges two sorted arrays. Args: a (list): The first sorted array. b (list): The second sorted array. Returns: list: Returns sorted array containing all elements from a and b. \"\"\" result = [] i = j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] <= b [ j ]: result . append ( a [ i ]) i += 1 else : result . append ( b [ j ]) j += 1 while i < len ( a ): result . append ( a [ i ]) i += 1 while j < len ( b ): result . append ( b [ j ]) j += 1 return result return split_array ( nums )","title":"merge_sort()"},{"location":"algorithms/sorting/#pyinterview.sorting.quick_sort","text":"Sort an array using the quick sort algorithm. Parameters: Name Type Description Default nums list The unsorted input array. required Returns: Type Description list The sorted output array. Source code in pyinterview/sorting.py def quick_sort ( nums : list ) -> list : \"\"\"Sort an array using the quick sort algorithm. Args: nums (list): The unsorted input array. Returns: list: The sorted output array. \"\"\" if len ( nums ) == 0 : return [] pivot = nums [ randint ( 0 , len ( nums ) - 1 )] smaller = [ x for x in nums if x < pivot ] equal = [ x for x in nums if x == pivot ] greater = [ x for x in nums if x > pivot ] return quick_sort ( smaller ) + equal + quick_sort ( greater )","title":"quick_sort()"},{"location":"algorithms/sorting/#pyinterview.sorting.topological_sort","text":"Produce a topological sorting (if one exists) using a BFS approach. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description list An array with a non-unique topological order of nodes. Source code in pyinterview/sorting.py def topological_sort ( edges : Sequence [ Sequence ]) -> list : \"\"\"Produce a topological sorting (if one exists) using a BFS approach. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: list: An array with a non-unique topological order of nodes. \"\"\" adj_list = directed_adj_list ( edges ) indegrees = inbound_degrees ( adj_list ) sources = find_sources ( indegrees ) result = [] while len ( sources ) > 0 : source = sources . popleft () result . append ( source ) for neighbor in adj_list [ source ]: indegrees [ neighbor ] -= 1 if indegrees [ neighbor ] == 0 : sources . append ( neighbor ) return result [:: - 1 ] if len ( result ) == len ( adj_list ) else []","title":"topological_sort()"},{"location":"data_structures/graphs/","text":"Graphs \u00b6 directed_adj_list ( edges ) \u00b6 Creates a directed graph represented as an adjacency list. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description dict An adjacency list where key = node and values = neighbors of that node. Source code in pyinterview/graphs.py def directed_adj_list ( edges : Sequence [ Sequence ]) -> dict : \"\"\"Creates a directed graph represented as an adjacency list. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: dict: An adjacency list where key = node and values = neighbors of that node. \"\"\" d = {} for start , end in edges : if start not in d : d [ start ] = [] d [ start ] . append ( end ) if end not in d : d [ end ] = [] return d find_sources ( indegrees ) \u00b6 Find sources (nodes that have 0 inbound edges). Parameters: Name Type Description Default indegrees dict A dictionary where the key is a graph node and the value is the number of inbound edges. required Returns: Type Description deque A deque containing source nodes. Source code in pyinterview/graphs.py def find_sources ( indegrees : dict ) -> deque : \"\"\"Find sources (nodes that have 0 inbound edges). Args: indegrees (dict): A dictionary where the key is a graph node \\ and the value is the number of inbound edges. Returns: deque: A deque containing source nodes. \"\"\" sources = deque () for node in indegrees : if indegrees [ node ] == 0 : sources . append ( node ) return sources inbound_degrees ( adj_list ) \u00b6 Calculate the inbound degree of each node in a graph. Parameters: Name Type Description Default adj_list dict An adjacency list. Can be from an undirected or directed graph. required Returns: Type Description dict A dictionary where the key is a graph node and the value is the number of inbound edges. Source code in pyinterview/graphs.py def inbound_degrees ( adj_list : dict ) -> dict : \"\"\"Calculate the inbound degree of each node in a graph. Args: adj_list (dict): An adjacency list. Can be from an undirected or directed graph. Returns: dict: A dictionary where the key is a graph node \\ and the value is the number of inbound edges. \"\"\" indegrees = { node : 0 for node in adj_list } for node in adj_list : for neighbor in adj_list [ node ]: indegrees [ neighbor ] += 1 return indegrees undirected_adj_list ( edges ) \u00b6 Creates an undirected graph represented as an adjacency list. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description dict An adjacency list where key = node and values = neighbors of that node. Source code in pyinterview/graphs.py def undirected_adj_list ( edges : Sequence [ Sequence ]) -> dict : \"\"\"Creates an undirected graph represented as an adjacency list. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: dict: An adjacency list where key = node and values = neighbors of that node. \"\"\" d = {} for start , end in edges : if start not in d : d [ start ] = [] d [ start ] . append ( end ) if end not in d : d [ end ] = [] d [ end ] . append ( start ) return d","title":"Graphs"},{"location":"data_structures/graphs/#graphs","text":"","title":"Graphs"},{"location":"data_structures/graphs/#pyinterview.graphs.directed_adj_list","text":"Creates a directed graph represented as an adjacency list. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description dict An adjacency list where key = node and values = neighbors of that node. Source code in pyinterview/graphs.py def directed_adj_list ( edges : Sequence [ Sequence ]) -> dict : \"\"\"Creates a directed graph represented as an adjacency list. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: dict: An adjacency list where key = node and values = neighbors of that node. \"\"\" d = {} for start , end in edges : if start not in d : d [ start ] = [] d [ start ] . append ( end ) if end not in d : d [ end ] = [] return d","title":"directed_adj_list()"},{"location":"data_structures/graphs/#pyinterview.graphs.find_sources","text":"Find sources (nodes that have 0 inbound edges). Parameters: Name Type Description Default indegrees dict A dictionary where the key is a graph node and the value is the number of inbound edges. required Returns: Type Description deque A deque containing source nodes. Source code in pyinterview/graphs.py def find_sources ( indegrees : dict ) -> deque : \"\"\"Find sources (nodes that have 0 inbound edges). Args: indegrees (dict): A dictionary where the key is a graph node \\ and the value is the number of inbound edges. Returns: deque: A deque containing source nodes. \"\"\" sources = deque () for node in indegrees : if indegrees [ node ] == 0 : sources . append ( node ) return sources","title":"find_sources()"},{"location":"data_structures/graphs/#pyinterview.graphs.inbound_degrees","text":"Calculate the inbound degree of each node in a graph. Parameters: Name Type Description Default adj_list dict An adjacency list. Can be from an undirected or directed graph. required Returns: Type Description dict A dictionary where the key is a graph node and the value is the number of inbound edges. Source code in pyinterview/graphs.py def inbound_degrees ( adj_list : dict ) -> dict : \"\"\"Calculate the inbound degree of each node in a graph. Args: adj_list (dict): An adjacency list. Can be from an undirected or directed graph. Returns: dict: A dictionary where the key is a graph node \\ and the value is the number of inbound edges. \"\"\" indegrees = { node : 0 for node in adj_list } for node in adj_list : for neighbor in adj_list [ node ]: indegrees [ neighbor ] += 1 return indegrees","title":"inbound_degrees()"},{"location":"data_structures/graphs/#pyinterview.graphs.undirected_adj_list","text":"Creates an undirected graph represented as an adjacency list. Parameters: Name Type Description Default edges Sequence[Sequence] A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. required Returns: Type Description dict An adjacency list where key = node and values = neighbors of that node. Source code in pyinterview/graphs.py def undirected_adj_list ( edges : Sequence [ Sequence ]) -> dict : \"\"\"Creates an undirected graph represented as an adjacency list. Args: edges (Sequence[Sequence]): A list of edges pairs, ex: [('A', 'B'), ('A', 'C')]. Returns: dict: An adjacency list where key = node and values = neighbors of that node. \"\"\" d = {} for start , end in edges : if start not in d : d [ start ] = [] d [ start ] . append ( end ) if end not in d : d [ end ] = [] d [ end ] . append ( start ) return d","title":"undirected_adj_list()"},{"location":"data_structures/heaps/","text":"Heaps \u00b6","title":"Heaps"},{"location":"data_structures/heaps/#heaps","text":"","title":"Heaps"},{"location":"data_structures/linked_lists/","text":"Linked lists \u00b6 LL_to_array ( head ) \u00b6 Convert a linked list into an array. Parameters: Name Type Description Default head ListNode The head node of the linked list. required Returns: Type Description list A new array containing the values from the linked list in order. Source code in pyinterview/linked_lists.py def LL_to_array ( head : ListNode ) -> list : \"\"\"Convert a linked list into an array. Args: head (ListNode): The head node of the linked list. Returns: list: A new array containing the values from the linked list in order. \"\"\" if head is None : return [] itr = head result = [] while itr : result . append ( itr . val ) itr = itr . next return result append_LL ( head , element ) \u00b6 Append an element to the end of a linked list. Parameters: Name Type Description Default head Optional[ListNode] The head node of the linked list. required element Union[int, float, str] The value of the ListNode element to be appended. required Returns: Type Description ListNode The head node of the linked list. Source code in pyinterview/linked_lists.py def append_LL ( head : ListNode , element : Union [ int , float , str ]) -> Optional [ ListNode ]: \"\"\"Append an element to the end of a linked list. Args: head (Optional[ListNode]): The head node of the linked list. element (Union[int, float, str]): The value of the ListNode element \\ to be appended. Returns: ListNode: The head node of the linked list. \"\"\" if head is None : print ( \"Linked List is empty!\" ) else : itr = head while itr . next : itr = itr . next itr . next = ListNode ( element ) return head array_to_LL ( array ) \u00b6 Convert an array into a linked list. Parameters: Name Type Description Default array list The array which will be converted. required Returns: Type Description ListNode The head node of the new linked list. Source code in pyinterview/linked_lists.py def array_to_LL ( array : list ) -> ListNode : \"\"\"Convert an array into a linked list. Args: array (list): The array which will be converted. Returns: ListNode: The head node of the new linked list. \"\"\" return ListNode ( 0 ) pop_LL ( head ) \u00b6 Pop the last element from a linked list. Parameters: Name Type Description Default head Optional[ListNode] The head node of the linked list. required Returns: Type Description ListNode The element that used to be the last element of the linked list. Source code in pyinterview/linked_lists.py def pop_LL ( head : ListNode ) -> Optional [ ListNode ]: \"\"\"Pop the last element from a linked list. Args: head (Optional[ListNode]): The head node of the linked list. Returns: ListNode: The element that used to be the last element of the linked list. \"\"\" if head is None : print ( \"Linked List is empty!\" ) elif head . next is None : print ( \"Linked List only contains one node!\" ) else : itr = head while itr . next . next : itr = itr . next popped = itr . next itr . next = None return popped remove_LL ( head , element ) \u00b6 Removes the first node in the linked list that has a given value. Parameters: Name Type Description Default head ListNode The head node of the linked list. required element Union[int, float, str] The value of the ListNode element to be removed. required Returns: Type Description ListNode The head node of the linked list. Source code in pyinterview/linked_lists.py def remove_LL ( head : ListNode , element : Union [ int , float , str ]) -> ListNode : \"\"\"Removes the first node in the linked list that has a given value. Args: head (ListNode): The head node of the linked list. element (Union[int, float, str]): The value of the ListNode element \\ to be removed. Returns: ListNode: The head node of the linked list. \"\"\" return ListNode ( 0 ) reverse_LL ( head ) \u00b6 Reverse a linked list in place. Parameters: Name Type Description Default head ListNode The head node of the linked list. required Returns: Type Description ListNode The head node of the reversed linked list. Source code in pyinterview/linked_lists.py def reverse_LL ( head : ListNode ) -> ListNode : \"\"\"Reverse a linked list in place. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The head node of the reversed linked list. \"\"\" itr = head prev = None while itr : next = itr . next itr . next = prev prev = itr itr = next return prev","title":"Linked lists"},{"location":"data_structures/linked_lists/#linked-lists","text":"","title":"Linked lists"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.LL_to_array","text":"Convert a linked list into an array. Parameters: Name Type Description Default head ListNode The head node of the linked list. required Returns: Type Description list A new array containing the values from the linked list in order. Source code in pyinterview/linked_lists.py def LL_to_array ( head : ListNode ) -> list : \"\"\"Convert a linked list into an array. Args: head (ListNode): The head node of the linked list. Returns: list: A new array containing the values from the linked list in order. \"\"\" if head is None : return [] itr = head result = [] while itr : result . append ( itr . val ) itr = itr . next return result","title":"LL_to_array()"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.append_LL","text":"Append an element to the end of a linked list. Parameters: Name Type Description Default head Optional[ListNode] The head node of the linked list. required element Union[int, float, str] The value of the ListNode element to be appended. required Returns: Type Description ListNode The head node of the linked list. Source code in pyinterview/linked_lists.py def append_LL ( head : ListNode , element : Union [ int , float , str ]) -> Optional [ ListNode ]: \"\"\"Append an element to the end of a linked list. Args: head (Optional[ListNode]): The head node of the linked list. element (Union[int, float, str]): The value of the ListNode element \\ to be appended. Returns: ListNode: The head node of the linked list. \"\"\" if head is None : print ( \"Linked List is empty!\" ) else : itr = head while itr . next : itr = itr . next itr . next = ListNode ( element ) return head","title":"append_LL()"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.array_to_LL","text":"Convert an array into a linked list. Parameters: Name Type Description Default array list The array which will be converted. required Returns: Type Description ListNode The head node of the new linked list. Source code in pyinterview/linked_lists.py def array_to_LL ( array : list ) -> ListNode : \"\"\"Convert an array into a linked list. Args: array (list): The array which will be converted. Returns: ListNode: The head node of the new linked list. \"\"\" return ListNode ( 0 )","title":"array_to_LL()"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.pop_LL","text":"Pop the last element from a linked list. Parameters: Name Type Description Default head Optional[ListNode] The head node of the linked list. required Returns: Type Description ListNode The element that used to be the last element of the linked list. Source code in pyinterview/linked_lists.py def pop_LL ( head : ListNode ) -> Optional [ ListNode ]: \"\"\"Pop the last element from a linked list. Args: head (Optional[ListNode]): The head node of the linked list. Returns: ListNode: The element that used to be the last element of the linked list. \"\"\" if head is None : print ( \"Linked List is empty!\" ) elif head . next is None : print ( \"Linked List only contains one node!\" ) else : itr = head while itr . next . next : itr = itr . next popped = itr . next itr . next = None return popped","title":"pop_LL()"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.remove_LL","text":"Removes the first node in the linked list that has a given value. Parameters: Name Type Description Default head ListNode The head node of the linked list. required element Union[int, float, str] The value of the ListNode element to be removed. required Returns: Type Description ListNode The head node of the linked list. Source code in pyinterview/linked_lists.py def remove_LL ( head : ListNode , element : Union [ int , float , str ]) -> ListNode : \"\"\"Removes the first node in the linked list that has a given value. Args: head (ListNode): The head node of the linked list. element (Union[int, float, str]): The value of the ListNode element \\ to be removed. Returns: ListNode: The head node of the linked list. \"\"\" return ListNode ( 0 )","title":"remove_LL()"},{"location":"data_structures/linked_lists/#pyinterview.linked_lists.reverse_LL","text":"Reverse a linked list in place. Parameters: Name Type Description Default head ListNode The head node of the linked list. required Returns: Type Description ListNode The head node of the reversed linked list. Source code in pyinterview/linked_lists.py def reverse_LL ( head : ListNode ) -> ListNode : \"\"\"Reverse a linked list in place. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The head node of the reversed linked list. \"\"\" itr = head prev = None while itr : next = itr . next itr . next = prev prev = itr itr = next return prev","title":"reverse_LL()"},{"location":"data_structures/trees/","text":"Trees \u00b6 deserialize ( nodes ) \u00b6 Construct a tree from a level order traversal list of nodes. Parameters: Name Type Description Default nodes list A list of nodes from a level order traversal. Missing children need to be denoted as \"X\". required Returns: Type Description Optional[TreeNode] Returns the root node of the new tree. Source code in pyinterview/trees.py def deserialize ( nodes : list ) -> Optional [ TreeNode ]: \"\"\"Construct a tree from a level order traversal list of nodes. Args: nodes (list): A list of nodes from a level order traversal. Missing \\ children need to be denoted as \"X\". Returns: Optional[TreeNode]: Returns the root node of the new tree. \"\"\" if not nodes : return None root = TreeNode ( int ( nodes [ 0 ])) q = deque () q . append ( root ) i = 1 while len ( q ) > 0 : current = q . popleft () if nodes [ i ] != \"X\" : current . left = TreeNode ( int ( nodes [ i ])) q . append ( current . left ) i += 1 if nodes [ i ] != \"X\" : current . right = TreeNode ( int ( nodes [ i ])) q . append ( current . right ) i += 1 return root in_order_traversal ( root ) \u00b6 Perform an in order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in in order traversal order. Source code in pyinterview/trees.py def in_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform an in order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in in order traversal order. \"\"\" result = [] if root is None : return [] result += in_order_traversal ( root . left ) result . append ( root . val ) result += in_order_traversal ( root . right ) return result level_order_traversal ( root ) \u00b6 Perform a level order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list[list] A list of lists where the index of each sublist is the level in the tree, and the elements of that sublist are the nodes at that level from left to right. Source code in pyinterview/trees.py def level_order_traversal ( root : TreeNode ) -> list [ list ]: \"\"\"Perform a level order tree traversal. Args: root (TreeNode): The root node. Returns: list[list]: A list of lists where the index of each sublist is the level in the tree, and the elements of that sublist are the nodes at that level from left to right. \"\"\" if root is None : return [] q = deque () q . append ( root ) result = [] while q : level = [] for _ in range ( len ( q )): current = q . popleft () level . append ( current . val ) for branch in current . left , current . right : if branch : q . append ( branch ) result . append ( level ) return result post_order_traversal ( root ) \u00b6 Perform a post order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in post order traversal order. Source code in pyinterview/trees.py def post_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform a post order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in post order traversal order. \"\"\" result = [] if root is None : return [] result += in_order_traversal ( root . left ) result += in_order_traversal ( root . right ) result . append ( root . val ) return result pre_order_traversal ( root ) \u00b6 Perform a pre order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in pre order traversal order. Source code in pyinterview/trees.py def pre_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform a pre order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in pre order traversal order. \"\"\" result = [] if root is None : return [] result . append ( root . val ) result += in_order_traversal ( root . left ) result += in_order_traversal ( root . right ) return result serialize ( root ) \u00b6 Generate a list of tree nodes using level order traversal. Notably, missing children nodes are denoted with an \"X\". This is so that the tree can be completely reconstructed from just the output list. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list Tbe list of nodes in level order traversal order. Missing children are denoted with an \"X\". Source code in pyinterview/trees.py def serialize ( root : TreeNode ) -> list : \"\"\"Generate a list of tree nodes using level order traversal. Notably, missing children nodes are denoted with an \"X\". This is so that the tree can be completely reconstructed from just the output list. Args: root (TreeNode): The root node. Returns: list: Tbe list of nodes in level order traversal order. Missing \\ children are denoted with an \"X\". \"\"\" if not root : return [] q = deque () q . append ( root ) result = [] while len ( q ) > 0 : current = q . popleft () if current : result . append ( str ( current . val )) else : result . append ( \"X\" ) continue for branch in [ current . left , current . right ]: q . append ( branch ) return result","title":"Trees"},{"location":"data_structures/trees/#trees","text":"","title":"Trees"},{"location":"data_structures/trees/#pyinterview.trees.deserialize","text":"Construct a tree from a level order traversal list of nodes. Parameters: Name Type Description Default nodes list A list of nodes from a level order traversal. Missing children need to be denoted as \"X\". required Returns: Type Description Optional[TreeNode] Returns the root node of the new tree. Source code in pyinterview/trees.py def deserialize ( nodes : list ) -> Optional [ TreeNode ]: \"\"\"Construct a tree from a level order traversal list of nodes. Args: nodes (list): A list of nodes from a level order traversal. Missing \\ children need to be denoted as \"X\". Returns: Optional[TreeNode]: Returns the root node of the new tree. \"\"\" if not nodes : return None root = TreeNode ( int ( nodes [ 0 ])) q = deque () q . append ( root ) i = 1 while len ( q ) > 0 : current = q . popleft () if nodes [ i ] != \"X\" : current . left = TreeNode ( int ( nodes [ i ])) q . append ( current . left ) i += 1 if nodes [ i ] != \"X\" : current . right = TreeNode ( int ( nodes [ i ])) q . append ( current . right ) i += 1 return root","title":"deserialize()"},{"location":"data_structures/trees/#pyinterview.trees.in_order_traversal","text":"Perform an in order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in in order traversal order. Source code in pyinterview/trees.py def in_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform an in order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in in order traversal order. \"\"\" result = [] if root is None : return [] result += in_order_traversal ( root . left ) result . append ( root . val ) result += in_order_traversal ( root . right ) return result","title":"in_order_traversal()"},{"location":"data_structures/trees/#pyinterview.trees.level_order_traversal","text":"Perform a level order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list[list] A list of lists where the index of each sublist is the level in the tree, and the elements of that sublist are the nodes at that level from left to right. Source code in pyinterview/trees.py def level_order_traversal ( root : TreeNode ) -> list [ list ]: \"\"\"Perform a level order tree traversal. Args: root (TreeNode): The root node. Returns: list[list]: A list of lists where the index of each sublist is the level in the tree, and the elements of that sublist are the nodes at that level from left to right. \"\"\" if root is None : return [] q = deque () q . append ( root ) result = [] while q : level = [] for _ in range ( len ( q )): current = q . popleft () level . append ( current . val ) for branch in current . left , current . right : if branch : q . append ( branch ) result . append ( level ) return result","title":"level_order_traversal()"},{"location":"data_structures/trees/#pyinterview.trees.post_order_traversal","text":"Perform a post order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in post order traversal order. Source code in pyinterview/trees.py def post_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform a post order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in post order traversal order. \"\"\" result = [] if root is None : return [] result += in_order_traversal ( root . left ) result += in_order_traversal ( root . right ) result . append ( root . val ) return result","title":"post_order_traversal()"},{"location":"data_structures/trees/#pyinterview.trees.pre_order_traversal","text":"Perform a pre order tree traversal. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list A list of nodes sorted in pre order traversal order. Source code in pyinterview/trees.py def pre_order_traversal ( root : TreeNode ) -> list : \"\"\"Perform a pre order tree traversal. Args: root (TreeNode): The root node. Returns: list: A list of nodes sorted in pre order traversal order. \"\"\" result = [] if root is None : return [] result . append ( root . val ) result += in_order_traversal ( root . left ) result += in_order_traversal ( root . right ) return result","title":"pre_order_traversal()"},{"location":"data_structures/trees/#pyinterview.trees.serialize","text":"Generate a list of tree nodes using level order traversal. Notably, missing children nodes are denoted with an \"X\". This is so that the tree can be completely reconstructed from just the output list. Parameters: Name Type Description Default root TreeNode The root node. required Returns: Type Description list Tbe list of nodes in level order traversal order. Missing children are denoted with an \"X\". Source code in pyinterview/trees.py def serialize ( root : TreeNode ) -> list : \"\"\"Generate a list of tree nodes using level order traversal. Notably, missing children nodes are denoted with an \"X\". This is so that the tree can be completely reconstructed from just the output list. Args: root (TreeNode): The root node. Returns: list: Tbe list of nodes in level order traversal order. Missing \\ children are denoted with an \"X\". \"\"\" if not root : return [] q = deque () q . append ( root ) result = [] while len ( q ) > 0 : current = q . popleft () if current : result . append ( str ( current . val )) else : result . append ( \"X\" ) continue for branch in [ current . left , current . right ]: q . append ( branch ) return result","title":"serialize()"},{"location":"data_structures/tries/","text":"Tries \u00b6","title":"Tries"},{"location":"data_structures/tries/#tries","text":"","title":"Tries"}]}